From 39ccab092158110dcc06bf5439bb46ee84608672 Mon Sep 17 00:00:00 2001
From: Dave <zz4077@comcast.net>
Date: Sat, 14 Jun 2014 20:02:38 -0600
Subject: [PATCH 14/26] Undo changes from code editor and other unnecessary
 changes

---
 CHANGELOG |   2 +
 ffmpeg.c  |  77 ++++++++-------
 netcam.c  | 328 +++++++++++++++++++++++++++++++-------------------------------
 3 files changed, 209 insertions(+), 198 deletions(-)

diff --git a/CHANGELOG b/CHANGELOG
index 8da2d47..c537cde 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -60,6 +60,8 @@ Features
    * Revised INSTALL with samples(Mr-Dave)
    * Revisions for RTSP and code standard.(Mr-Dave)
    * Plugged most(?) memory leaks in RTSP. (Mr-Dave)
+   * Undo changes caused by code editor and other unnecessary changes
+
    
 Bugfixes
    * Avoid segfault detecting strerror_r() version GNU or SUSv3. (Angel Carpintero)
diff --git a/ffmpeg.c b/ffmpeg.c
index dbcd7ca..611e11e 100644
--- a/ffmpeg.c
+++ b/ffmpeg.c
@@ -24,9 +24,9 @@
 #    define FFMPEG_NO_NONSTD_MPEG1
 #endif /* LIBAVCODEC_BUILD > 4680 */
 
-#if defined LIBAVFORMAT_VERSION_MAJOR && defined LIBAVFORMAT_VERSION_MINOR
+#if defined LIBAVFORMAT_VERSION_MAJOR && defined LIBAVFORMAT_VERSION_MINOR 
 #   if LIBAVFORMAT_VERSION_MAJOR < 53 && LIBAVFORMAT_VERSION_MINOR < 45
-#       define GUESS_NO_DEPRECATED
+#       define GUESS_NO_DEPRECATED 
 #   endif
 #endif
 
@@ -50,7 +50,7 @@
 #    define AVSTREAM_CODEC_PTR(avs_ptr) (&avs_ptr->codec)
 #endif /* LIBAVFORMAT_BUILD >= 4629 */
 
-// AV_VERSION_INT(a, b, c) (a<<16 | b<<8 | c)
+// AV_VERSION_INT(a, b, c) (a<<16 | b<<8 | c) 
 // (54*2^16 | 6*2^8 | 100)
 #if LIBAVFORMAT_BUILD >= 3540580
 #define FF_API_NEW_AVIO
@@ -79,9 +79,9 @@ static unsigned char mpeg1_trailer[] = {0x00, 0x00, 0x01, 0xb7};
 // FFMPEG API changed in 0.8
 #if defined FF_API_NEW_AVIO
 
-// TODO
-
+// TODO 
 
+	
 #else
 
 /**
@@ -268,7 +268,7 @@ static int mpeg1_write_trailer(AVFormatContext *s)
 void ffmpeg_init()
 {
     MOTION_LOG(NTC, TYPE_ENCODER, NO_ERRNO, "%s: ffmpeg LIBAVCODEC_BUILD %d"
-               " LIBAVFORMAT_BUILD %d", LIBAVCODEC_BUILD,
+               " LIBAVFORMAT_BUILD %d", LIBAVCODEC_BUILD, 
                LIBAVFORMAT_BUILD);
     av_register_all();
 
@@ -289,12 +289,10 @@ void ffmpeg_init()
     mpeg1_file_protocol.url_close = file_protocol.url_close;
 
 /* Register the append file protocol. */
-#ifdef have_av_register_protocol2
+#ifdef FFMPEG_V55
     av_register_protocol2(&mpeg1_file_protocol, sizeof(mpeg1_file_protocol));
-#elif defined have_av_register_protocol
-    av_register_protocol(&mpeg1_file_protocol);
 #else
-#   warning av_register_protocolXXX missing
+    av_register_protocol(&mpeg1_file_protocol);
 #endif
 
 #endif // FF_API_NEW_AVIO
@@ -331,10 +329,10 @@ static AVOutputFormat *get_oformat(const char *codec, char *filename)
          * result in a muxed output file, which isn't appropriate here.
          */
 #ifdef GUESS_NO_DEPRECATED
-        of = guess_format("mpeg1video", NULL, NULL);
+        of = guess_format("mpeg1video", NULL, NULL);        
 #else
         of = av_guess_format("mpeg1video", NULL, NULL);
-#endif
+#endif 
         /* But we want the trailer to be correctly written. */
         if (of)
             of->write_trailer = mpeg1_write_trailer;
@@ -349,14 +347,14 @@ static AVOutputFormat *get_oformat(const char *codec, char *filename)
         ext = ".avi";
 #ifdef GUESS_NO_DEPRECATED
         of = guess_format("mpeg1video", NULL, NULL);
-#else
+#else        
         of = av_guess_format("avi", NULL, NULL);
-#endif
+#endif        
     } else if (strcmp(codec, "msmpeg4") == 0) {
         ext = ".avi";
 #ifdef GUESS_NO_DEPRECATED
         of = guess_format("mpeg1video", NULL, NULL);
-#else
+#else        
         of = av_guess_format("avi", NULL, NULL);
 #endif
         /* Manually override the codec id. */
@@ -367,16 +365,16 @@ static AVOutputFormat *get_oformat(const char *codec, char *filename)
         ext = ".swf";
 #ifdef GUESS_NO_DEPRECATED
         of = guess_format("mpeg1video", NULL, NULL);
-#else
+#else        
         of = av_guess_format("swf", NULL, NULL);
-#endif
+#endif        
     } else if (strcmp(codec, "flv") == 0) {
         ext = ".flv";
 #ifdef GUESS_NO_DEPRECATED
         of = guess_format("mpeg1video", NULL, NULL);
-#else
+#else        
         of = av_guess_format("flv", NULL, NULL);
-#endif
+#endif        
         of->video_codec = CODEC_ID_FLV1;
     } else if (strcmp(codec, "ffv1") == 0) {
         ext = ".avi";
@@ -396,7 +394,7 @@ static AVOutputFormat *get_oformat(const char *codec, char *filename)
         ext = ".mov";
 #ifdef GUESS_NO_DEPRECATED
         of = guess_format("mpeg1video", NULL, NULL);
-#else
+#else        
         of = av_guess_format("mov", NULL, NULL);
 #endif
 	    }
@@ -460,12 +458,10 @@ struct ffmpeg *ffmpeg_open(char *ffmpeg_video_codec, char *filename,
     snprintf(ffmpeg->codec, sizeof(ffmpeg->codec), "%s", ffmpeg_video_codec);
 
     /* Allocation the output media context. */
-#ifdef have_avformat_alloc_context
+#ifdef FFMPEG_V55
     ffmpeg->oc = avformat_alloc_context();
-#elif defined have_av_avformat_alloc_context
-    ffmpeg->oc = av_alloc_format_context();
 #else
-    ffmpeg->oc = av_mallocz(sizeof(AVFormatContext));
+    ffmpeg->oc = av_alloc_format_context();
 #endif
 
     if (!ffmpeg->oc) {
@@ -487,7 +483,7 @@ struct ffmpeg *ffmpeg_open(char *ffmpeg_video_codec, char *filename,
     /* Create a new video stream and initialize the codecs. */
     ffmpeg->video_st = NULL;
     if (ffmpeg->oc->oformat->video_codec != CODEC_ID_NONE) {
-#if defined FF_API_NEW_AVIO
+#if defined FF_API_NEW_AVIO 
         ffmpeg->video_st = avformat_new_stream(ffmpeg->oc, NULL /* Codec */);
 #else
         ffmpeg->video_st = av_new_stream(ffmpeg->oc, 0);
@@ -508,11 +504,11 @@ struct ffmpeg *ffmpeg_open(char *ffmpeg_video_codec, char *filename,
 
     ffmpeg->c     = c = AVSTREAM_CODEC_PTR(ffmpeg->video_st);
     c->codec_id   = ffmpeg->oc->oformat->video_codec;
-#if LIBAVCODEC_VERSION_MAJOR < 53
+#if LIBAVCODEC_VERSION_MAJOR < 53    
     c->codec_type = CODEC_TYPE_VIDEO;
 #else
     c->codec_type = AVMEDIA_TYPE_VIDEO;
-#endif
+#endif    
     is_mpeg1      = c->codec_id == CODEC_ID_MPEG1VIDEO;
 
     if (strcmp(ffmpeg_video_codec, "ffv1") == 0)
@@ -619,7 +615,11 @@ struct ffmpeg *ffmpeg_open(char *ffmpeg_video_codec, char *filename,
     }
 
     /* Allocate the encoded raw picture. */
+#ifdef FFMPEG_V55
+    ffmpeg->picture = av_frame_alloc();
+#else
     ffmpeg->picture = avcodec_alloc_frame();
+#endif
 
     if (!ffmpeg->picture) {
         MOTION_LOG(ERR, TYPE_ENCODER, NO_ERRNO, "%s: avcodec_alloc_frame -"
@@ -852,11 +852,11 @@ int ffmpeg_put_frame(struct ffmpeg *ffmpeg, AVFrame *pic)
     if (ffmpeg->oc->oformat->flags & AVFMT_RAWPICTURE) {
         /* Raw video case. The API will change slightly in the near future for that. */
 #ifdef FFMPEG_AVWRITEFRAME_NEWAPI
-#   if LIBAVCODEC_VERSION_MAJOR < 53
+#   if LIBAVCODEC_VERSION_MAJOR < 53        
         pkt.flags |= PKT_FLAG_KEY;
 #   else
-        pkt.flags |= AV_PKT_FLAG_KEY;
-#   endif
+        pkt.flags |= AV_PKT_FLAG_KEY;  
+#   endif        
         pkt.data = (uint8_t *)pic;
         pkt.size = sizeof(AVPicture);
         ret = av_write_frame(ffmpeg->oc, &pkt);
@@ -870,10 +870,10 @@ int ffmpeg_put_frame(struct ffmpeg *ffmpeg, AVFrame *pic)
         pkt.data = ffmpeg->video_outbuf;
         pkt.size = ffmpeg->video_outbuf_size;
 
-        out_size = avcodec_encode_video2(AVSTREAM_CODEC_PTR(ffmpeg->video_st),
+        out_size = avcodec_encode_video2(AVSTREAM_CODEC_PTR(ffmpeg->video_st), 
                                         &pkt, pic, &got_packet_ptr);
         if (out_size < 0)
-            // Error encondig
+            // Error encondig 
             out_size = 0;
         else
             out_size = pkt.size;
@@ -892,11 +892,11 @@ int ffmpeg_put_frame(struct ffmpeg *ffmpeg, AVFrame *pic)
             pkt.pts = AVSTREAM_CODEC_PTR(ffmpeg->video_st)->coded_frame->pts;
 
             if (AVSTREAM_CODEC_PTR(ffmpeg->video_st)->coded_frame->key_frame)
-#   if LIBAVCODEC_VERSION_MAJOR < 53
+#   if LIBAVCODEC_VERSION_MAJOR < 53                
                 pkt.flags |= PKT_FLAG_KEY;
 #   else
                 pkt.flags |= AV_PKT_FLAG_KEY;
-#   endif
+#   endif                
 
             pkt.data = ffmpeg->video_outbuf;
             pkt.size = out_size;
@@ -936,7 +936,11 @@ AVFrame *ffmpeg_prepare_frame(struct ffmpeg *ffmpeg, unsigned char *y,
 {
     AVFrame *picture;
 
+#ifdef FFMPEG_V55
+    picture = av_frame_alloc();
+#else
     picture = avcodec_alloc_frame();
+#endif
 
     if (!picture) {
         MOTION_LOG(ERR, TYPE_ENCODER, SHOW_ERRNO, "%s: Could not alloc frame");
@@ -985,7 +989,12 @@ void ffmpeg_deinterlace(unsigned char *img, int width, int height)
     picture.linesize[2] = width2;
 
     /* We assume using 'PIX_FMT_YUV420P' always */
+#ifdef FFMPEG_V55
+    MOTION_LOG(ALR, TYPE_NETCAM, NO_ERRNO, "%s: Deinterlace depreciated for recent versions of FFMPEG.");
+#else
     avpicture_deinterlace(&picture, &picture, PIX_FMT_YUV420P, width, height);
+#endif
+
 
 #if !defined(__SSE_MATH__) && (defined(__i386__) || defined(__x86_64__))
     __asm__ __volatile__ ( "emms");
diff --git a/netcam.c b/netcam.c
index fa9d0fa..4a9b961 100644
--- a/netcam.c
+++ b/netcam.c
@@ -149,21 +149,21 @@ static void netcam_url_parse(struct url_t *parse_url, const char *text_url)
 {
     char *s;
     int i;
-#ifdef FFMPEG_V55
+#ifdef FFMPEG_V55    
     const char *re = "(http|ftp|mjpg|rtsp)://(((.*):(.*))@)?"
                      "([^/:]|[-.a-z0-9]+)(:([0-9]+))?($|(/[^:]*))";
 #else
     const char *re = "(http|ftp|mjpg)://(((.*):(.*))@)?"
                      "([^/:]|[-.a-z0-9]+)(:([0-9]+))?($|(/[^:]*))";
-#endif
+#endif                     
     regex_t pattbuf;
     regmatch_t matches[10];
 
-    if (!strncmp(text_url, "file", 4))
+    if (!strncmp(text_url, "file", 4)) 
         re = "(file)://(((.*):(.*))@)?"
              "([^/:]|[-.a-z0-9]*)(:([0-9]*))?($|(/[^:][/-_.a-z0-9]+))";
 
-    MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: Entry netcam_url_parse data %s",
+    MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: Entry netcam_url_parse data %s", 
                text_url);
 
     memset(parse_url, 0, sizeof(struct url_t));
@@ -211,10 +211,10 @@ static void netcam_url_parse(struct url_t *parse_url, const char *text_url)
             parse_url->port = 80;
         else if (!strcmp(parse_url->service, "ftp"))
             parse_url->port = 21;
-#ifdef FFMPEG_V55
+#ifdef FFMPEG_V55            
         else if (!strcmp(parse_url->service, "rtsp") && parse_url->port == 0)
             parse_url->port = 554;
-#endif
+#endif            
     }
 
     regfree(&pattbuf);
@@ -313,7 +313,7 @@ static long netcam_check_content_length(char *header)
                        " Content-Length but value %ld", length);
     }
 
-    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Content-Length %ld",
+    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Content-Length %ld", 
                length);
 
     return length;
@@ -341,7 +341,7 @@ static int netcam_check_keepalive(char *header)
         return -1;
 
     /* We do not detect the second field or other case mixes at present. */
-    if (content_type)
+    if (content_type) 
         free(content_type);
 
     return 1;
@@ -368,11 +368,11 @@ static int netcam_check_close(char *header)
 
     if (!header_process(header, "Connection", http_process_type, &type))
         return -1;
-
+    
     if (!strcmp(type, "close")) /* strcmp returns 0 for match. */
         ret = 1;
-
-    if (type)
+    
+    if (type) 
         free(type);
 
     return ret;
@@ -403,7 +403,7 @@ static int netcam_check_content_type(char *header)
     if (!header_process(header, "Content-type", http_process_type, &content_type))
         return -1;
 
-    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Content-type %s",
+    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Content-type %s", 
                content_type);
 
     if (!strcmp(content_type, "image/jpeg")) {
@@ -442,7 +442,7 @@ static int netcam_read_next_header(netcam_context_ptr netcam)
     char *header;
 
     /* Return if not connected */
-    if (netcam->sock == -1)
+    if (netcam->sock == -1) 
         return -1;
     /*
      * We are expecting a header which *must* contain a mime-type of
@@ -465,12 +465,12 @@ static int netcam_read_next_header(netcam_context_ptr netcam)
             if (retval != HG_OK) {
                 /* Header reported as not-OK, check to see if it's null. */
                 if (strlen(header) == 0) {
-                    MOTION_LOG(WRN, TYPE_NETCAM, NO_ERRNO, "%s: Error reading image header, "
+                    MOTION_LOG(WRN, TYPE_NETCAM, NO_ERRNO, "%s: Error reading image header, " 
                                "streaming mode (1). Null header.");
                 } else {
                     /* Header is not null. Output it in case it's a new camera with unknown headers. */
                     MOTION_LOG(WRN, TYPE_NETCAM, NO_ERRNO, "%s: Error reading image header, "
-                               "streaming mode (1). Unknown header '%s'",
+                               "streaming mode (1). Unknown header '%s'", 
                                header);
                  }
 
@@ -490,7 +490,7 @@ static int netcam_read_next_header(netcam_context_ptr netcam)
         retval = header_get(netcam, &header, HG_NONE);
 
         if (retval != HG_OK) {
-            MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Error reading image header (2)");
+            MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Error reading image header (2)"); 
             free(header);
             return -1;
         }
@@ -512,16 +512,16 @@ static int netcam_read_next_header(netcam_context_ptr netcam)
                 netcam->receiving->content_length = retval;
             } else {
                 netcam->receiving->content_length = 0;
-                MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Content-Length 0");
+                MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Content-Length 0"); 
                 free(header);
                 return -1;
-            }
-        }
+            }    
+        }    
 
         free(header);
     }
 
-    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Found image header record");
+    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Found image header record"); 
 
     free(header);
     return 0;
@@ -592,11 +592,11 @@ static int netcam_read_first_header(netcam_context_ptr netcam)
     while (1) {     /* 'Do forever' */
         ret = header_get(netcam, &header, HG_NONE);
 
-        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Received first header ('%s')",
+        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Received first header ('%s')", 
                    header);
 
         if (ret != HG_OK) {
-            MOTION_LOG(WRN, TYPE_NETCAM, NO_ERRNO, "%s: Error reading first header (%s)",
+            MOTION_LOG(WRN, TYPE_NETCAM, NO_ERRNO, "%s: Error reading first header (%s)", 
                        header);
             free(header);
             return -1;
@@ -609,15 +609,15 @@ static int netcam_read_first_header(netcam_context_ptr netcam)
 
                 free(header);
                 if (netcam->connect_keepalive) {
-                    /*
-                     * Cannot unset netcam->cnt->conf.netcam_keepalive as it is assigned const
-                     * But we do unset the netcam keepalive flag which was set in netcam_start
+                    /* 
+                     * Cannot unset netcam->cnt->conf.netcam_keepalive as it is assigned const 
+                     * But we do unset the netcam keepalive flag which was set in netcam_start 
                      * This message is logged as Information as it would be useful to know
-                     * if your netcam often returns bad HTTP result codes.
+                     * if your netcam often returns bad HTTP result codes. 
                      */
                     netcam->connect_keepalive = FALSE;
                     free((void *)netcam->cnt->conf.netcam_keepalive);
-                    netcam->cnt->conf.netcam_keepalive = strdup("off");
+                    netcam->cnt->conf.netcam_keepalive = strdup("off"); 
                     MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: Removed netcam Keep-Alive flag"
                                "due to apparent closed HTTP connection.");
                 }
@@ -643,18 +643,18 @@ static int netcam_read_first_header(netcam_context_ptr netcam)
              */
             switch (ret) {
             case 1:         /* Not streaming */
-                if (netcam->connect_keepalive)
-                    MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: Non-streaming camera "
+                if (netcam->connect_keepalive) 
+                    MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: Non-streaming camera " 
                                "(keep-alive set)");
                 else
-                    MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: Non-streaming camera "
+                    MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: Non-streaming camera " 
                                "(keep-alive not set)");
 
                 netcam->caps.streaming = NCS_UNSUPPORTED;
                 break;
 
             case 2:         /* Streaming */
-                MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Streaming camera");
+                MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Streaming camera"); 
 
                 netcam->caps.streaming = NCS_MULTIPART;
 
@@ -687,7 +687,7 @@ static int netcam_read_first_header(netcam_context_ptr netcam)
                 MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Unrecognized content type");
                 free(header);
                 return -1;
-
+                
             }
         } else if ((ret = (int) netcam_check_content_length(header)) >= 0) {
             MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: Content-length present");
@@ -695,7 +695,7 @@ static int netcam_read_first_header(netcam_context_ptr netcam)
             if (ret > 0) {
                 netcam->caps.content_length = 1;     /* Set flag */
                 netcam->receiving->content_length = ret;
-            } else {
+            } else { 
                 netcam->receiving->content_length = 0;
                 MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Content-length 0");
                 retval = -2;
@@ -704,18 +704,18 @@ static int netcam_read_first_header(netcam_context_ptr netcam)
             /* Note that we have received a Keep-Alive header, and thus the socket can be left open. */
             aliveflag = TRUE;
             netcam->keepalive_thisconn = TRUE;
-            /*
-             * This flag will not be set when a Streaming cam is in use, but that
-             * does not matter as the test below looks at Streaming state also.
+            /* 
+             * This flag will not be set when a Streaming cam is in use, but that 
+             * does not matter as the test below looks at Streaming state also.   
              */
         } else if (netcam_check_close(header) == TRUE) {
             /* Note that we have received a Connection: close header. */
             closeflag = TRUE;
-            /*
-             * This flag is acted upon below.
-             * Changed criterion and moved up from below to catch headers that cause returns.
+            /* 
+             * This flag is acted upon below. 
+             * Changed criterion and moved up from below to catch headers that cause returns. 
              */
-             MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: Found Conn: close header ('%s')",
+             MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: Found Conn: close header ('%s')", 
                         header);
         }
         free(header);
@@ -723,7 +723,7 @@ static int netcam_read_first_header(netcam_context_ptr netcam)
     free(header);
 
     if (netcam->caps.streaming == NCS_UNSUPPORTED && netcam->connect_keepalive) {
-
+        
         /* If we are a non-streaming (ie. Jpeg) netcam and keepalive is configured. */
 
         if (aliveflag) {
@@ -738,22 +738,22 @@ static int netcam_read_first_header(netcam_context_ptr netcam)
                     netcam->cnt->conf.netcam_keepalive = strdup("off");
                 } else {
                    /*
-                    * If not a streaming cam, and keepalive is set, and the flag shows we
+                    * If not a streaming cam, and keepalive is set, and the flag shows we 
                     * did not see a Keep-Alive field returned from netcam and a Close field.
                     * Not quite sure what the correct course of action is here. In for testing.
-                    */
+                    */ 
                     MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Both 'Connection: Keep-Alive' and "
                                "'Connection: close' header received. Motion continues unchanged.");
                 }
             } else {
-               /*
-                * aliveflag && !closeflag
+               /* 
+                * aliveflag && !closeflag 
                 *
-                * If not a streaming cam, and keepalive is set, and the flag shows we
+                * If not a streaming cam, and keepalive is set, and the flag shows we 
                 * just got a Keep-Alive field returned from netcam and no Close field.
                 * No action, as this is the normal case. In debug we print a notification.
                 */
-
+        
                 MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Received a Keep-Alive field in this"
                            "set of headers.");
             }
@@ -770,17 +770,17 @@ static int netcam_read_first_header(netcam_context_ptr netcam)
                     netcam->cnt->conf.netcam_keepalive = strdup("off");
                 } else {
                    /*
-                    * If not a streaming cam, and keepalive is set, and the flag shows we
+                    * If not a streaming cam, and keepalive is set, and the flag shows we 
                     * did not see a Keep-Alive field returned from netcam nor a Close field.
                     * Not quite sure what the correct course of action is here. In for testing.
-                    */
+                    */                                                                                                     
                     MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: No 'Connection: Keep-Alive' nor 'Connection: close'"
                                " header received.\n Motion continues unchanged.");
                 }
-            } else {
-                /*
-                 * !aliveflag & closeflag
-                 * If not a streaming cam, and keepalive is set, and the flag shows we
+            } else {  
+                /* 
+                 * !aliveflag & closeflag 
+                 * If not a streaming cam, and keepalive is set, and the flag shows we 
                  * received a 'Connection: close' field returned from netcam. It is not likely
                  * we will get a Keep-Alive and Close header together - this is picked up by
                  * the test code above.
@@ -805,11 +805,11 @@ static int netcam_read_first_header(netcam_context_ptr netcam)
                     free((void *)netcam->cnt->conf.netcam_keepalive);
                     netcam->cnt->conf.netcam_keepalive = strdup("off");
                     MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Removed netcam Keep-Alive flag because"
-                               " 'Connection: close' header received.\n Netcam does not support "
+                               " 'Connection: close' header received.\n Netcam does not support " 
                                "Keep-Alive. Motion continues in non-Keep-Alive.");
                 } else {
                     netcam->keepalive_timeup = TRUE;    /* We will close and re-open keep-alive */
-                    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "Keep-Alive has reached end of valid period.\n"
+                    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "Keep-Alive has reached end of valid period.\n" 
                                "Motion will close netcam, then resume Keep-Alive with a new socket.");
                 }
             }
@@ -873,7 +873,7 @@ static int netcam_connect(netcam_context_ptr netcam, int err_flag)
 
     /* Assure any previous connection has been closed - IF we are not in keepalive. */
     if (!netcam->connect_keepalive) {
-        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: disconnecting netcam "
+        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: disconnecting netcam " 
                    "since keep-alive not set.");
 
         netcam_disconnect(netcam);
@@ -891,13 +891,13 @@ static int netcam_connect(netcam_context_ptr netcam, int err_flag)
     } else if (netcam->sock == -1) {   /* We are in keepalive mode, check for invalid socket. */
         /* Must be first time, or closed, create a new socket. */
         if ((netcam->sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
-            MOTION_LOG(WRN, TYPE_NETCAM, SHOW_ERRNO, "%s: with keepalive set, invalid socket."
+            MOTION_LOG(WRN, TYPE_NETCAM, SHOW_ERRNO, "%s: with keepalive set, invalid socket." 
                        "This could be the first time. Creating a new one failed.");
             return -1;
         }
 
         MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: with keepalive set, invalid socket."
-                   "This could be first time, created a new one with fd %d",
+                   "This could be first time, created a new one with fd %d", 
                     netcam->sock);
 
         /* Record that this connection has not yet received a Keep-Alive header. */
@@ -909,7 +909,7 @@ static int netcam_connect(netcam_context_ptr netcam, int err_flag)
             return -1;
         }
 
-        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: SO_KEEPALIVE is %s",
+        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: SO_KEEPALIVE is %s", 
                    optval ? "ON":"OFF");
 
         /* Set the option active. */
@@ -922,9 +922,9 @@ static int netcam_connect(netcam_context_ptr netcam, int err_flag)
         }
 
         MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: SO_KEEPALIVE set on socket.");
-    }
-
-    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: re-using socket %d since keepalive is set.",
+    } 
+    
+    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: re-using socket %d since keepalive is set.", 
                netcam->sock);
 
     /* Lookup the hostname given in the netcam URL. */
@@ -976,7 +976,7 @@ static int netcam_connect(netcam_context_ptr netcam, int err_flag)
     /* If the connect failed with anything except EINPROGRESS, error. */
     if ((ret < 0) && (back_err != EINPROGRESS)) {
         if (!err_flag)
-            MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: connect() failed (%d)",
+            MOTION_LOG(ERR, TYPE_NETCAM, SHOW_ERRNO, "%s: connect() failed (%d)", 
                        back_err);
 
         MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: disconnecting netcam (4)");
@@ -995,9 +995,9 @@ static int netcam_connect(netcam_context_ptr netcam, int err_flag)
     if (ret == 0) {            /* 0 means timeout. */
         if (!err_flag)
             MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: timeout on connect()");
-
+        
         MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: disconnecting netcam (2)");
-
+        
         netcam_disconnect(netcam);
         return -1;
     }
@@ -1062,7 +1062,7 @@ static void netcam_check_buffsize(netcam_buff_ptr buff, size_t numbytes)
         real_alloc += NETCAM_BUFFSIZE;
 
     new_size = buff->size + real_alloc;
-
+    
     MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: expanding buffer from [%d/%d] to [%d/%d] bytes.",
                (int) buff->used, (int) buff->size,
                (int) buff->used, new_size);
@@ -1321,9 +1321,9 @@ static int netcam_read_html_jpeg(netcam_context_ptr netcam)
      * as 'latest', and make the buffer previously in 'latest' become
      * the new 'receiving'.
      */
-    if (gettimeofday(&curtime, NULL) < 0)
+    if (gettimeofday(&curtime, NULL) < 0) 
         MOTION_LOG(WRN, TYPE_NETCAM, SHOW_ERRNO, "%s: gettimeofday");
-
+    
     netcam->receiving->image_time = curtime;
 
     /*
@@ -1336,7 +1336,7 @@ static int netcam_read_html_jpeg(netcam_context_ptr netcam)
                                  1000000.0 * (curtime.tv_sec - netcam->last_image.tv_sec) +
                                  (curtime.tv_usec- netcam->last_image.tv_usec)) / 10.0;
 
-        MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: Calculated frame time %f",
+        MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: Calculated frame time %f", 
                    netcam->av_frame_time);
     }
     netcam->last_image = curtime;
@@ -1362,7 +1362,7 @@ static int netcam_read_html_jpeg(netcam_context_ptr netcam)
                        "netcam since keep-alive not set.");
 
             netcam_disconnect(netcam);
-        }
+        } 
         MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: leaving netcam connected.");
     }
 
@@ -1403,9 +1403,9 @@ static int netcam_http_request(netcam_context_ptr netcam)
          * safe to include it as part of this loop
          * (Not always true now Keep-Alive is implemented).
          */
-        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: about to try to connect, time #%d",
+        MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: about to try to connect, time #%d", 
                    ix);
-
+        
         if (netcam_connect(netcam, 0) != 0) {
             MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "Failed to open camera - check your config "
                        "and that netcamera is online");
@@ -1468,9 +1468,9 @@ static int netcam_mjpg_buffer_refill(netcam_context_ptr netcam)
 
     netcam->response->buffer_left = retval;
     netcam->response->buffer_pos = netcam->response->buffer;
-
+ 
     MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Refilled buffer with [%d]"
-               " bytes from the network.", retval);
+               " bytes from the network.", retval); 
 
     return retval;
 }
@@ -1478,7 +1478,7 @@ static int netcam_mjpg_buffer_refill(netcam_context_ptr netcam)
 /**
  * netcam_read_mjpg_jpeg
  *
- *     This routine reads from a netcam using a MJPG-chunk based
+ *     This routine reads from a netcam using a MJPG-chunk based 
  *     protocol, used by Linksys WVC200 for example.
  *     This implementation has been made by reverse-engineering
  *     the protocol, so it may contain bugs and should be considered as
@@ -1488,7 +1488,7 @@ static int netcam_mjpg_buffer_refill(netcam_context_ptr netcam)
  *
  *     The stream consists of JPG pictures, spanned across multiple
  *     MJPG chunks (in general 3 chunks, altough that's not guaranteed).
- *
+ * 
  *     Each data chunk can range from 1 to 65535 bytes + a header, altough
  *     i have not seen anything bigger than 20000 bytes + a header.
  *
@@ -1538,7 +1538,7 @@ static int netcam_read_mjpg_jpeg(netcam_context_ptr netcam)
 
             read_bytes += retval;
 
-            MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Read [%d/%d] header bytes.",
+            MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Read [%d/%d] header bytes.", 
                        read_bytes, sizeof(mh));
 
             /* If we don't have received a full header, refill our buffer. */
@@ -1572,26 +1572,26 @@ static int netcam_read_mjpg_jpeg(netcam_context_ptr netcam)
                                 mh.mh_chunksize - read_bytes);
             read_bytes += retval;
             MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: Read [%d/%d] chunk bytes,"
-                       " [%d/%d] total", read_bytes, mh.mh_chunksize,
+                       " [%d/%d] total", read_bytes, mh.mh_chunksize, 
                        buffer->used + read_bytes, mh.mh_framesize);
 
             if (retval < (int) (mh.mh_chunksize - read_bytes)) {
                 /* MOTION_LOG(EMG, TYPE_NETCAM, NO_ERRNO, "Chunk incomplete, going to refill."); */
                 if (netcam_mjpg_buffer_refill(netcam) < 0)
                     return -1;
-
+                
             }
         }
         buffer->used += read_bytes;
 
         MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: Chunk complete,"
-                   " buffer used [%d] bytes.", buffer->used);
+                   " buffer used [%d] bytes.", buffer->used); 
 
         /* Is our JPG image complete ? */
         if (mh.mh_framesize == buffer->used) {
             MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: Image complete,"
                        " buffer used [%d] bytes.", buffer->used);
-            break;
+            break;    
         }
         /* MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: Rlen now at [%d] bytes", rlen); */
     }
@@ -1601,9 +1601,9 @@ static int netcam_read_mjpg_jpeg(netcam_context_ptr netcam)
      * as 'latest', and make the buffer previously in 'latest' become
      * the new 'receiving'.
      */
-    if (gettimeofday(&curtime, NULL) < 0)
+    if (gettimeofday(&curtime, NULL) < 0) 
         MOTION_LOG(WRN, TYPE_NETCAM, SHOW_ERRNO, "%s: gettimeofday");
-
+    
     netcam->receiving->image_time = curtime;
 
     /*
@@ -1616,7 +1616,7 @@ static int netcam_read_mjpg_jpeg(netcam_context_ptr netcam)
                                  1000000.0 * (curtime.tv_sec - netcam->last_image.tv_sec) +
                                  (curtime.tv_usec- netcam->last_image.tv_usec)) / 10.0;
 
-        MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: Calculated frame time %f",
+        MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: Calculated frame time %f", 
                    netcam->av_frame_time);
     }
     netcam->last_image = curtime;
@@ -1676,9 +1676,9 @@ static int netcam_read_ftp_jpeg(netcam_context_ptr netcam)
         buffer->used += len;
     } while (len > 0);
 
-    if (gettimeofday(&curtime, NULL) < 0)
+    if (gettimeofday(&curtime, NULL) < 0) 
         MOTION_LOG(WRN, TYPE_NETCAM, SHOW_ERRNO, "%s: gettimeofday");
-
+    
     netcam->receiving->image_time = curtime;
     /*
      * Calculate our "running average" time for this netcam's
@@ -1690,7 +1690,7 @@ static int netcam_read_ftp_jpeg(netcam_context_ptr netcam)
                                  (curtime.tv_sec - netcam->last_image.tv_sec) +
                                  (curtime.tv_usec- netcam->last_image.tv_usec)) / 10.0;
 
-        MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: Calculated frame time %f",
+        MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: Calculated frame time %f", 
                    netcam->av_frame_time);
     }
 
@@ -1748,17 +1748,17 @@ static int netcam_read_file_jpeg(netcam_context_ptr netcam)
     /*int fstat(int filedes, struct stat *buf);*/
     do {
         if (stat(netcam->file->path, &statbuf)) {
-            MOTION_LOG(CRT, TYPE_NETCAM, SHOW_ERRNO, "%s: stat(%s) error",
+            MOTION_LOG(CRT, TYPE_NETCAM, SHOW_ERRNO, "%s: stat(%s) error", 
                        netcam->file->path);
             return -1;
         }
-
+    
         MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: statbuf.st_mtime[%d]"
-                   " != last_st_mtime[%d]", statbuf.st_mtime,
+                   " != last_st_mtime[%d]", statbuf.st_mtime, 
                    netcam->file->last_st_mtime);
 
         /* its waits POLLING_TIMEOUT */
-        if (loop_counter>((POLLING_TIMEOUT*1000*1000)/(POLLING_TIME/1000))) {
+        if (loop_counter>((POLLING_TIMEOUT*1000*1000)/(POLLING_TIME/1000))) { 
             MOTION_LOG(CRT, TYPE_NETCAM, NO_ERRNO, "%s: waiting new file image"
                        " timeout");
             return -1;
@@ -1766,9 +1766,9 @@ static int netcam_read_file_jpeg(netcam_context_ptr netcam)
 
         MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: delay waiting new"
                    " file image ");
-
+        
         //its waits 5seconds - READ_TIMEOUT
-        //SLEEP(netcam->timeout.tv_sec, netcam->timeout.tv_usec*1000);
+        //SLEEP(netcam->timeout.tv_sec, netcam->timeout.tv_usec*1000); 
         SLEEP(0, POLLING_TIME); // its waits 500ms
         /*return -1;*/
         loop_counter++;
@@ -1776,26 +1776,26 @@ static int netcam_read_file_jpeg(netcam_context_ptr netcam)
     } while (statbuf.st_mtime == netcam->file->last_st_mtime);
 
     netcam->file->last_st_mtime = statbuf.st_mtime;
-
+    
     MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: processing new file image -"
                " st_mtime %d", netcam->file->last_st_mtime);
-
+    
     /* Assure there's enough room in the buffer. */
     while (buffer->size < (size_t)statbuf.st_size)
-        netcam_check_buffsize(buffer, statbuf.st_size);
-
+        netcam_check_buffsize(buffer, statbuf.st_size); 
+    
 
     /* Do the read */
     netcam->file->control_file_desc = open(netcam->file->path, O_RDONLY);
     if (netcam->file->control_file_desc < 0) {
-        MOTION_LOG(CRT, TYPE_NETCAM, NO_ERRNO, "%s: open(%s) error: %d",
+        MOTION_LOG(CRT, TYPE_NETCAM, NO_ERRNO, "%s: open(%s) error: %d", 
                    netcam->file->path, netcam->file->control_file_desc);
         return -1;
     }
 
-    if ((len = read(netcam->file->control_file_desc,
+    if ((len = read(netcam->file->control_file_desc, 
                     buffer->ptr + buffer->used, statbuf.st_size)) < 0) {
-        MOTION_LOG(CRT, TYPE_NETCAM, NO_ERRNO, "%s: read(%s) error: %d",
+        MOTION_LOG(CRT, TYPE_NETCAM, NO_ERRNO, "%s: read(%s) error: %d", 
                    netcam->file->control_file_desc, len);
         return -1;
     }
@@ -1805,7 +1805,7 @@ static int netcam_read_file_jpeg(netcam_context_ptr netcam)
 
     if (gettimeofday(&curtime, NULL) < 0)
         MOTION_LOG(WRN, TYPE_NETCAM, SHOW_ERRNO, "%s: gettimeofday");
-
+    
     netcam->receiving->image_time = curtime;
     /*
      * Calculate our "running average" time for this netcam's
@@ -1816,8 +1816,8 @@ static int netcam_read_file_jpeg(netcam_context_ptr netcam)
         netcam->av_frame_time = ((9.0 * netcam->av_frame_time) + 1000000.0 *
                                  (curtime.tv_sec - netcam->last_image.tv_sec) +
                                  (curtime.tv_usec- netcam->last_image.tv_usec)) / 10.0;
-
-        MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: Calculated frame time %f",
+    
+        MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: Calculated frame time %f", 
                    netcam->av_frame_time);
     }
 
@@ -1844,12 +1844,12 @@ static int netcam_read_file_jpeg(netcam_context_ptr netcam)
     pthread_mutex_unlock(&netcam->mutex);
 
     MOTION_LOG(DBG, TYPE_NETCAM, NO_ERRNO, "%s: End");
-
+    
     return 0;
 }
 
 
-tfile_context *file_new_context(void)
+tfile_context *file_new_context(void) 
 {
     tfile_context *ret;
 
@@ -1862,7 +1862,7 @@ tfile_context *file_new_context(void)
     return ret;
 }
 
-void file_free_context(tfile_context* ctxt)
+void file_free_context(tfile_context* ctxt) 
 {
     if (ctxt == NULL)
         return;
@@ -1873,7 +1873,7 @@ void file_free_context(tfile_context* ctxt)
     free(ctxt);
 }
 
-static int netcam_setup_file(netcam_context_ptr netcam, struct url_t *url)
+static int netcam_setup_file(netcam_context_ptr netcam, struct url_t *url) 
 {
 
     if ((netcam->file = file_new_context()) == NULL)
@@ -1888,7 +1888,7 @@ static int netcam_setup_file(netcam_context_ptr netcam, struct url_t *url)
     netcam->file->path = url->path;
     url->path = NULL;
 
-    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: netcam->file->path %s",
+    MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: netcam->file->path %s", 
                netcam->file->path);
 
     netcam_url_free(url);
@@ -1939,7 +1939,7 @@ static void *netcam_handler_loop(void *arg)
         if (netcam->response) {    /* If html input */
             if (netcam->caps.streaming == NCS_UNSUPPORTED) {
                 /* Non-streaming ie. jpeg */
-                if (!netcam->connect_keepalive ||
+                if (!netcam->connect_keepalive || 
                     (netcam->connect_keepalive && netcam->keepalive_timeup)) {
                     /* If keepalive flag set but time up, time to close this socket. */
                     if (netcam->connect_keepalive && netcam->keepalive_timeup) {
@@ -1974,7 +1974,7 @@ static void *netcam_handler_loop(void *arg)
                         MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Unrecognized image"
                                    " header (%d)", retval);
                     } else if (retval != -1) {
-                        MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Error in header (%d)",
+                        MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Error in header (%d)", 
                                    retval);
                     }
                     /* Need to have a dynamic delay here. */
@@ -1995,7 +1995,7 @@ static void *netcam_handler_loop(void *arg)
                     if ((retval = netcam_read_first_header(netcam) != 2)) {
                         if (retval > 0) {
                             MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO,
-                                      "%s: Unrecognized image header (%d)",
+                                      "%s: Unrecognized image header (%d)",  
                                       retval);
                         } else if (retval != -1) {
                             MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO,
@@ -2017,8 +2017,7 @@ static void *netcam_handler_loop(void *arg)
                  */
             }
         }
-
-
+        
 #ifdef FFMPEG_V55
         if (netcam->caps.streaming == NCS_RTSP) {
             if (netcam->rtsp->format_context == NULL) {      // We must have disconnected.  Try to reconnect
@@ -2036,8 +2035,8 @@ static void *netcam_handler_loop(void *arg)
             }
         }
 #endif
-        if (netcam->get_image(netcam) < 0) {
-            if (netcam->caps.streaming != NCS_RTSP) {
+        if (netcam->caps.streaming != NCS_RTSP) {
+            if (netcam->get_image(netcam) < 0) {
                 MOTION_LOG(ERR, TYPE_NETCAM, NO_ERRNO, "%s: Error getting jpeg image");
                 /* If FTP connection, attempt to re-connect to server. */
                 if (netcam->ftp) {
@@ -2048,6 +2047,7 @@ static void *netcam_handler_loop(void *arg)
                 continue;
             }
         }
+
         /*
          * FIXME
          * Need to check whether the image was received / decoded
@@ -2126,7 +2126,7 @@ static void *netcam_handler_loop(void *arg)
  * Returns:             0 on success,
  *                      or -1 if an fatal error occurs.
  */
-static int netcam_http_build_url(netcam_context_ptr netcam, struct url_t *url)
+static int netcam_http_build_url(netcam_context_ptr netcam, struct url_t *url) 
 {
     struct context *cnt = netcam->cnt;
     const char *ptr;                  /* Working var */
@@ -2140,8 +2140,8 @@ static int netcam_http_build_url(netcam_context_ptr netcam, struct url_t *url)
     memset(netcam->response, 0, sizeof(struct rbuf));
 
     MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Netcam has flags:"
-               " HTTP/1.0: %s HTTP/1.1: %s Keep-Alive %s.",
-               netcam->connect_http_10 ? "1":"0", netcam->connect_http_11 ? "1":"0",
+               " HTTP/1.0: %s HTTP/1.1: %s Keep-Alive %s.",  
+               netcam->connect_http_10 ? "1":"0", netcam->connect_http_11 ? "1":"0", 
                netcam->connect_keepalive ? "ON":"OFF");
 
     /*
@@ -2161,7 +2161,7 @@ static int netcam_http_build_url(netcam_context_ptr netcam, struct url_t *url)
     if (ptr) {
         userpass = mymalloc(strlen(ptr) + 3);
         strcpy(userpass, ptr);
-    } else {
+    } else { 
         userpass = NULL;
     }
 
@@ -2214,13 +2214,13 @@ static int netcam_http_build_url(netcam_context_ptr netcam, struct url_t *url)
         ptr = mymalloc(strlen(url->service) + strlen(url->host)
                        + strlen(url->path) + 4);
         sprintf((char *)ptr, "http://%s%s", url->host, url->path);
-
+        
         netcam->connect_keepalive = FALSE; /* Disable Keepalive if proxy */
         free((void *)netcam->cnt->conf.netcam_keepalive);
         netcam->cnt->conf.netcam_keepalive = strdup("off");
 
         MOTION_LOG(NTC, TYPE_NETCAM, NO_ERRNO, "%s: "
-                   "Removed netcam_keepalive flag due to proxy set."
+                   "Removed netcam_keepalive flag due to proxy set." 
                    "Proxy is incompatible with Keep-Alive.");
     } else {
         /* If no proxy, set as netcam_url path. */
@@ -2235,22 +2235,22 @@ static int netcam_http_build_url(netcam_context_ptr netcam, struct url_t *url)
 
     ix += strlen(ptr);
 
-    /*
+    /* 
      * Now add the required number of characters for the close header
      * or Keep-Alive header.  We test the flag which can be unset if
      * there is a problem (rather than the flag in the conf structure
      * which is read-only.
      */
-
-    if (netcam->connect_keepalive)
+ 
+    if (netcam->connect_keepalive) 
         ix += strlen(connect_req_keepalive);
-    else
+    else 
         ix += strlen(connect_req_close);
-
+    
 
     /*
-     * Point to either the HTTP 1.0 or 1.1 request header set
-     * If the configuration is anything other than 1.1, use 1.0
+     * Point to either the HTTP 1.0 or 1.1 request header set     
+     * If the configuration is anything other than 1.1, use 1.0   
      * as a default. This avoids a chance of being left with none.
      */
     if (netcam->connect_http_11 == TRUE)
@@ -2267,13 +2267,13 @@ static int netcam_http_build_url(netcam_context_ptr netcam, struct url_t *url)
 
     /* Now create the request string with an sprintf. */
     sprintf(netcam->connect_request, connect_req, ptr,
-            netcam->connect_host);
+            netcam->connect_host); 
 
-    if (netcam->connect_keepalive)
+    if (netcam->connect_keepalive)  
         strcat(netcam->connect_request, connect_req_keepalive);
-    else
+    else 
         strcat(netcam->connect_request, connect_req_close);
-
+    
 
     if (userpass) {
         strcat(netcam->connect_request, request_pass);
@@ -2307,7 +2307,7 @@ static int netcam_http_build_url(netcam_context_ptr netcam, struct url_t *url)
  * Returns:     0 on success (camera link ok) or -1 if an error occurred.
  *
  */
-static int netcam_setup_html(netcam_context_ptr netcam, struct url_t *url)
+static int netcam_setup_html(netcam_context_ptr netcam, struct url_t *url) 
 {
     /*
      * This netcam is http-based, so build the required URL and
@@ -2383,7 +2383,7 @@ static int netcam_setup_mjpg(netcam_context_ptr netcam, struct url_t *url)
     return 0;
 }
 
-static int netcam_setup_ftp(netcam_context_ptr netcam, struct url_t *url)
+static int netcam_setup_ftp(netcam_context_ptr netcam, struct url_t *url) 
 {
     struct context *cnt = netcam->cnt;
     const char *ptr;
@@ -2497,7 +2497,7 @@ static int netcam_setup_rtsp(netcam_context_ptr netcam, struct url_t *url)
     if ((netcam->rtsp->user != NULL) && (netcam->rtsp->pass != NULL)) {
         ptr = mymalloc(strlen(url->service) + strlen(netcam->connect_host)
 	          + 5 + strlen(url->path) + 5
-              + strlen(netcam->rtsp->user) + strlen(netcam->rtsp->pass) + 3 );
+              + strlen(netcam->rtsp->user) + strlen(netcam->rtsp->pass) + 4 );
         sprintf((char *)ptr, "%s://%s:%s@%s:%d%s",
                 url->service,netcam->rtsp->user,netcam->rtsp->pass,
                 netcam->connect_host, netcam->connect_port, url->path);
@@ -2551,7 +2551,7 @@ static int netcam_setup_rtsp(netcam_context_ptr netcam, struct url_t *url)
  *      error reply from the system call.
  *
  */
-ssize_t netcam_recv(netcam_context_ptr netcam, void *buffptr, size_t buffsize)
+ssize_t netcam_recv(netcam_context_ptr netcam, void *buffptr, size_t buffsize) 
 {
     ssize_t retval;
     fd_set fd_r;
@@ -2580,7 +2580,7 @@ ssize_t netcam_recv(netcam_context_ptr netcam, void *buffptr, size_t buffsize)
  *      handled.
  *      This function is also called from motion_init if first time connection
  *      fails and we start retrying until we get a valid first frame from the
- *      camera.
+ *      camera. 
  *
  * Parameters:
  *
@@ -2632,7 +2632,7 @@ void netcam_cleanup(netcam_context_ptr netcam, int init_retry_flag)
 
     if (netcam->caps.streaming == NCS_UNSUPPORTED)
         pthread_cond_signal(&netcam->cap_cond);
-
+    
 
     /*
      * Once the camera-handler gets to the end of it's loop (probably as
@@ -2672,45 +2672,45 @@ void netcam_cleanup(netcam_context_ptr netcam, int init_retry_flag)
     pthread_mutex_unlock(&netcam->mutex);
 
     /* and cleanup the rest of the netcam_context structure. */
-    if (netcam->connect_host != NULL)
+    if (netcam->connect_host != NULL) 
         free(netcam->connect_host);
 
-    if (netcam->connect_request != NULL)
+    if (netcam->connect_request != NULL) 
         free(netcam->connect_request);
+    
 
-
-    if (netcam->boundary != NULL)
+    if (netcam->boundary != NULL) 
         free(netcam->boundary);
-
+    
 
     if (netcam->latest != NULL) {
-        if (netcam->latest->ptr != NULL)
+        if (netcam->latest->ptr != NULL) 
             free(netcam->latest->ptr);
-
+        
         free(netcam->latest);
     }
 
     if (netcam->receiving != NULL) {
-        if (netcam->receiving->ptr != NULL)
+        if (netcam->receiving->ptr != NULL) 
             free(netcam->receiving->ptr);
-
+        
         free(netcam->receiving);
     }
 
     if (netcam->jpegbuf != NULL) {
-        if (netcam->jpegbuf->ptr != NULL)
+        if (netcam->jpegbuf->ptr != NULL) 
             free(netcam->jpegbuf->ptr);
-
+    
         free(netcam->jpegbuf);
     }
 
-    if (netcam->ftp != NULL)
+    if (netcam->ftp != NULL) 
         ftp_free_context(netcam->ftp);
-    else
+    else 
         netcam_disconnect(netcam);
+    
 
-
-    if (netcam->response != NULL)
+    if (netcam->response != NULL) 
         free(netcam->response);
 
     pthread_mutex_destroy(&netcam->mutex);
@@ -2774,9 +2774,9 @@ int netcam_next(struct context *cnt, unsigned char *image)
      * approach is to just return a NULL (failed) to the caller (an
      * error message has already been produced by the libjpeg routines).
      */
-    if (setjmp(netcam->setjmp_buffer))
+    if (setjmp(netcam->setjmp_buffer)) 
         return NETCAM_GENERAL_ERROR | NETCAM_JPEG_CONV_ERROR;
-
+    
     /* If there was no error, process the latest image buffer. */
     return netcam_proc_jpeg(netcam, image);
 }
@@ -2844,7 +2844,7 @@ int netcam_start(struct context *cnt)
     pthread_cond_init(&netcam->cap_cond, NULL);
     pthread_cond_init(&netcam->pic_ready, NULL);
     pthread_cond_init(&netcam->exiting, NULL);
-
+    
     /* Initialise the average frame time to the user's value. */
     netcam->av_frame_time = 1000000.0 / cnt->conf.frame_limit;
 
@@ -2881,7 +2881,7 @@ int netcam_start(struct context *cnt)
     netcam_url_parse(&url, cnt->conf.netcam_url);
 
     if (!url.host) {
-        MOTION_LOG(CRT, TYPE_NETCAM, NO_ERRNO, "%s: Invalid netcam_url (%s)",
+        MOTION_LOG(CRT, TYPE_NETCAM, NO_ERRNO, "%s: Invalid netcam_url (%s)", 
                    cnt->conf.netcam_url);
         netcam_url_free(&url);
         return -1;
@@ -2895,7 +2895,7 @@ int netcam_start(struct context *cnt)
 
     /* Get HTTP Mode (1.0 default, 1.0 Keep-Alive, 1.1) flag from config
      * and report its stata for debug reasons.
-     * The flags in the conf structure is read only and cannot be
+     * The flags in the conf structure is read only and cannot be 
      * unset if the Keep-Alive needs to be switched off (ie. netcam does
      * not turn out to support it. That is handled by unsetting the flags
      * in the context structures (cnt->...) only.
@@ -2916,9 +2916,9 @@ int netcam_start(struct context *cnt)
     }
 
     MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: Netcam_http parameter '%s'"
-               " converts to flags: HTTP/1.0: %s HTTP/1.1: %s Keep-Alive %s.",
-               cnt->conf.netcam_keepalive,
-               netcam->connect_http_10 ? "1":"0", netcam->connect_http_11 ? "1":"0",
+               " converts to flags: HTTP/1.0: %s HTTP/1.1: %s Keep-Alive %s.", 
+               cnt->conf.netcam_keepalive, 
+               netcam->connect_http_10 ? "1":"0", netcam->connect_http_11 ? "1":"0", 
                netcam->connect_keepalive ? "ON":"OFF");
 
     /* Initialise the netcam socket to -1 to trigger a connection by the keep-alive logic. */
@@ -2945,13 +2945,13 @@ int netcam_start(struct context *cnt)
 
         strcpy(url.service, "http"); /* Put back a real URL service. */
         retval = netcam_setup_mjpg(netcam, &url);
-#ifdef FFMPEG_V55
+#ifdef FFMPEG_V55        
     } else if ((url.service) && (!strcmp(url.service, "rtsp"))) {
         MOTION_LOG(INF, TYPE_NETCAM, NO_ERRNO, "%s: now calling"
                     " netcam_setup_rtsp()");
 
         retval = netcam_setup_rtsp(netcam, &url);
-#endif
+#endif        
     } else {
         MOTION_LOG(CRT, TYPE_NETCAM, NO_ERRNO, "%s: Invalid netcam service '%s' - "
                    "must be http, ftp, mjpg or file.", url.service);
@@ -3008,7 +3008,7 @@ int netcam_start(struct context *cnt)
                        " is not modulo 8", netcam->height);
             return -3;
         }
-#ifdef FFMPEG_V55
+#ifdef FFMPEG_V55        
     } else {
         // not jpeg, get the dimensions
         netcam->width = netcam->rtsp->codec_context->width;
-- 
1.8.1.4

